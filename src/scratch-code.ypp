%require "3.0.4"																									//require a specific bison version (from https://www.gnu.org/software/bison/manual/html_node/Calc_002b_002b-Parser.html)
%language "c++"
%defines																											//many of the following directive are explained here: https://www.gnu.org/software/bison/manual/html_node/Decl-Summary.html
%define parser_class_name {ScratchCodeParser}
%define api.token.constructor
%define api.value.type variant																						//use fancy variants to be compatible with C++ (from https://www.gnu.org/software/bison/manual/html_node/C_002b_002b-Variants.html)
%define parse.assert																								//TODO: check this: https://www.gnu.org/software/bison/manual/html_node/Tracing.html
%code requires
{
	#include <string>
	#include <ast/AST.hpp>
	class ScratchCodeDriver;
}



//the parsing context
%param { ScratchCodeDriver& driver }																				//a reference to a "ScratchCodeDriver" will become a parameter for the "ScratchCodeParser" class constructor
%locations
%initial-action
{
	//initialize the initial location (@$ evaluates to "yyla.location", thus it is not directly associated with my code)
	//"yyla" is in gen/scratch-code.tab.cpp and is a "symbol_type"=instance of "basic_symbol<by_type>" templated class
	//"basic_symbol" class contains member "location" of type "location_type"=instance of "location" class
	//"location" class is in gen/location.hh, has "begin" and "end" members of type "position"
	//"position" class is in gen/position.hh, has "filename" member of type std::string*
	@$.begin.filename = @$.end.filename = driver.getFilenamePointer();
	
	//setup variables needed for parsing
	std::shared_ptr<ast::StatementList> parentStatementList(driver.getParsedStatementList());
};
%define parse.trace
%define parse.error verbose

%code
{
	#include "ScratchCodeDriver.hpp"
}

%define api.token.prefix {TOK_}
%token
	END 0 "end of file"
	IF "if"
	ELSE "else"
	WHILE "while"
	FOR "for"
	RETURN "return"
	ROUND_BRACKET_OPEN "("
	ROUND_BRACKET_CLOSED ")"
	SQUARE_BRACKET_OPEN "["
	SQUARE_BRACKET_CLOSED "]"
	CURLY_BRACKET_OPEN "{"
	CURLY_BRACKET_CLOSED "}"
	COMMA ","
	SEMICOLON ";";
%token <std::string> IDENTIFIER "identifier"																		//define terminal symbol token types, each one needs to be associated with a field of the previous union
%token <ast::Lexer::ParsedVariableType> PARSED_VARIABLE_TYPE "variable type"
%printer { yyoutput << ast::Lexer::getParsedVariableTypeString($$); } <ast::Lexer::ParsedVariableType>
%printer { yyoutput << $$; } <*>



%%
%start unit;
unit:																												//the first rule defined is the highest-level rule, which in our case is just the concept of a whole "scratch code file"
	expressions END;
expressions:
	%empty
  | expressions expression;
expression:
	variableDefinition
  | conditional { std::cout << "got a conditional" << std::endl; };
expressionsBlock:
	CURLY_BRACKET_OPEN expressions CURLY_BRACKET_CLOSED;
variableDefinition:
	PARSED_VARIABLE_TYPE IDENTIFIER SEMICOLON { driver.parentStatementList->addStatement(std::make_shared<ast::VariableDefinition>(driver.parentStatementList, $1, $2)); };
conditional:
	conditionalIf
  | conditionalIf conditionalElse;
conditionalIf:
	IF ROUND_BRACKET_OPEN ROUND_BRACKET_CLOSED expressionsBlock;
conditionalElse:
	ELSE expressionsBlock;
%%



#include "Main.hpp"

void yy::ScratchCodeParser::error(const location_type& loc, const std::string& message)
{
	driver.handleError(loc, message);
}

