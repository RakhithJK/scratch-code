%require "3.0.4"																									//require a specific bison version (from https://www.gnu.org/software/bison/manual/html_node/Calc_002b_002b-Parser.html)
%language "c++"
%defines																											//many of the following directive are explained here: https://www.gnu.org/software/bison/manual/html_node/Decl-Summary.html
%define parser_class_name {ScratchCodeParser}
%define api.token.constructor
%define api.value.type variant																						//use fancy variants to be compatible with C++ (from https://www.gnu.org/software/bison/manual/html_node/C_002b_002b-Variants.html)
%define parse.assert																								//TODO: check this: https://www.gnu.org/software/bison/manual/html_node/Tracing.html
%code requires
{
	#include <string>
	#include <ast/AST.hpp>
	class ScratchCodeDriver;
}



//the parsing context
%param { ScratchCodeDriver& driver }																				//a reference to a "ScratchCodeDriver" will become a parameter for the "ScratchCodeParser" class constructor
%locations
%initial-action
{
	//initialize the initial location (@$ evaluates to "yyla.location", thus it is not directly associated with my code)
	//"yyla" is in gen/scratch-code.tab.cpp and is a "symbol_type"=instance of "basic_symbol<by_type>" templated class
	//"basic_symbol" class contains member "location" of type "location_type"=instance of "location" class
	//"location" class is in gen/location.hh, has "begin" and "end" members of type "position"
	//"position" class is in gen/position.hh, has "filename" member of type std::string*
	@$.begin.filename = @$.end.filename = driver.getFilenamePointer();
};
%define parse.trace
%define parse.error verbose

%code
{
	#include "ScratchCodeDriver.hpp"
}

%define api.token.prefix {TOK_}
%token
	END 0 "end of file"
	IF "if"
	ELSE "else"
	WHILE "while"
	FOR "for"
	RETURN "return"
	ROUND_BRACKET_OPEN "("
	ROUND_BRACKET_CLOSED ")"
	SQUARE_BRACKET_OPEN "["
	SQUARE_BRACKET_CLOSED "]"
	CURLY_BRACKET_OPEN "{"
	CURLY_BRACKET_CLOSED "}"
	COMMA ","
	SEMICOLON ";";
%token <std::string> IDENTIFIER "identifier"																		//define terminal symbol token types, each one needs to be associated with a field of the previous union
%token <ast::Lexer::ParsedVariableType> PARSED_VARIABLE_TYPE "variable type"
%printer { yyoutput << ast::Lexer::getParsedVariableTypeString($$); } <ast::Lexer::ParsedVariableType>
%printer { yyoutput << $$; } <*>



%%
%start unit;
unit:																												//the first rule defined is the highest-level rule, which in our case is just the concept of a whole "scratch code file"
	expressions END;
expressions:
	%empty
  | expressions expression;
expression:
	variableDefinition
  | conditional;
expressionsBlock:
	CURLY_BRACKET_OPEN expressions CURLY_BRACKET_CLOSED expressionsBlockClosed
  | expression expressionsBlockClosed;
expressionsBlockClosed:
	%empty { driver.parentStatementList = std::static_pointer_cast<ast::StatementList>(driver.parentStatementList->getParent()->getParent()); };
variableDefinition:
	PARSED_VARIABLE_TYPE IDENTIFIER SEMICOLON
	{
		if(std::find_if(driver.variableDefinitions.begin(), driver.variableDefinitions.end(), [&](auto& varDef) { return (varDef->getType() == $1  &&  varDef->getName() == $2); }) != driver.variableDefinitions.end())
		{
			auto loc = @$;
			loc.begin.filename = loc.end.filename = driver.getFilenamePointer();
			throw yy::ScratchCodeParser::syntax_error(loc, "'" + $2 + "' is already defined");
		}
		auto newVarDef = std::make_shared<ast::VariableDefinition>(driver.parentStatementList, $1, $2);
		driver.parentStatementList->addStatement(newVarDef);
		driver.variableDefinitions.push_back(newVarDef);
	};
/*lValue:
	IDENTIFIER
	{
		if(std::find_if(driver.variableDefinitions.begin(), driver.variableDefinitions.end(), [&](auto& varDef) { return (varDef->getName() == $1); }) == driver.variableDefinitions.end())
			
	};
value:
	lValue;*/
conditional:
	conditionalIf;
//  | conditionalIf conditionalElse;
conditionalIf:
	IF ROUND_BRACKET_OPEN ROUND_BRACKET_CLOSED
	{
		auto newCond = std::make_shared<ast::Conditional>(driver.parentStatementList);
		newCond->addCondition(std::make_shared<ast::Value>(newCond));
		newCond->addConsequenceBody(std::make_shared<ast::StatementList>(newCond));
		driver.parentStatementList->addStatement(newCond);
		driver.parentStatementList = newCond->getConsequenceBodies()[0];
		//throw yy::ScratchCodeParser::syntax_error(@$1, "Dammit, I'm mad");
	} expressionsBlock;
//conditionalElse:
//	ELSE expressionsBlock;
%%



#include "Main.hpp"

void yy::ScratchCodeParser::error(const location_type& loc, const std::string& message)
{
	driver.handleError(loc, message);
}

